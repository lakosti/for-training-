////////////////////////МАСИВИ ТА ФУНКЦІЇ//////////////////////////////////////////

//-----------ітерації по масиву, тобто «перебрати» його поелементно.

// Якщо цикл знаходиться в тілі функції, то оператор break не припиняє виконання функції, а тільки перерве цикл. Для того щоб переривати виконання відразу циклу і функції, є оператор return.

//якщо необхідний доступ по індексу це цикл фор

//Масив - складний тип даних який ближче відноситься до об'єкта. ЗБЕРІГАЄ В СОБІ ДАНІ
//[] -- ЛІТЕРАЛ
// Для роботи з масивами використовуються два цикли в основному for / for of
// array.length --- довжина масиву
// array.length -1 --- останній елемент масиву
// break -- перериває цикл
// continue -- вихід із цикла і перехід на наступну ітерацію +=1
// деліметр - той символ чим розділяється рядок(тире, пробіл, посимвольно) // якщо немає такого деліметра як ми вказали у спліт тоді весь рядок буде масивом
// arguments -- псевдомасив (якщо різна кількість об'єктів)
//якщо масив в масиві то використовується рекурсія

/////////////////////////////////МЕТОДИ МАСИВУ/////////////////////////////////////////////////

// .split('') --- перетворює з рядка в масив розбиваючи його роздільником
// .join ('') --- обєднує елементи масиву у рядок
// .revers() --- розвертає/повертає елементи / слова (те що було перше стане останнє і навпаки)
// array.push(6, 7); // дадає в кінці елемент масиву
// console.log(Array.isArray(array)); // true -- перевірка на масив (true or false)
// array.pop(); // видаляє останній елемент масиву
// array.length = 0; // повністью очищує масив
// indexOf -- повертає індекс елемента починаючи з нуля, якщо не знайшов повертає - 1 --- перший неможливий індекс елемент в масиві
// includes -- перевіряє чи є даний елемент в масиві // true / false
// shift -- видаляє елементи на початку масиву
// unsift -- додає елементи на початку масиву
// splice -- додає видаляє заміняє будь який елемент масиву (універсальний)й//мутує масив (мутабельний)
// slice -- створює копію масиву (рідко викорис) // (з якого, по який(не включно)) // не мцутує масив// тобто //(1, 3)-- видалиться 1 і 2 // slice -вирізати все починаючи з x  і до останнього -1
// concat -- поєднує декілька масивів в один
// можна з'єднувати масиви і таким чином через спред [...name1,...name2]

// const fruits = ['apple', 'plum'];
// const age = [1, 2];
// const color = ['red', 'green'];
// const result = [...fruits, ...age, ...color];

///////////////ЦИКЛИ для масиву

// for -- якщо потрібно перебрати і замінити якийсь елемент масиву
// for of -- можна швидко без зайвих маніпуляцій перебрати масив але змінити нічого не можна
//while - дуже схожий до фора але самостійно ставити поствираз та лічильник

///////////////////////////

//arguments -- вбудований псевдомасив або ітерабельний об'єкт// щоб перетоворити в масив   const arr = [...arguments];

//                0     1       2     3       4
// const array = [1, 'Hello', null, true, [1, 2, 3]]; // до масива звертаємося по індексу (починається з нуля) розділяється комою /// порядковий номер масиву починається знизу
// //             1      2      3     4       5

// // console.log(typeof array); //object масив це я вид об'єкту
// // console.log(Array.isArray(array)); // true -- перевірка на масив (true or false)

// const first = array[1]; /// --- звернення до масиву
// console.log(first);
// const last = array[array.length - 1]; //останній елемент масиву// -1 тому що індекс на одиницю менший від довжини масиву,тобто порядкового номера
// console.log(last);

//////////цикл For
//let i = 0 -- бо індекс елемента починається з нуля
// i < array.length -- до яких пір буде виконуватися масив(всю його довжину)
// for (let i = 0; i < array.length; i += 1) {
//   // і --- просто лічильний (1,2,3,4)// щоб вивести дані з масива console.log(array[i])
//   const item = array[i]; //переназиваємо масив
//   if (Array.isArray(item)) {
//     for (let j = 0; j < item.length; j++) {
//       // звернення до масива в масиві (J -- прийнято викор. другою змінною)
//       console.log(item[j]);
//     }
//     continue; //перехід на наступну ітерацію
//   }
//   console.log(array[i]);
// }

///////цикл For of -- йому не потрібні ні які ні умови ні ітерації у нього вже все під капотом /// через ФОР ОФ не можна змінити елементи в масиві

// const array = [1, 'Hello', null, true, [1, 2, 3]];

// for (const item of array) {
//   // item -- назва масиву // ліворуч від ОФ - це назва масиву
//   //   console.log(item);
//   if (typeof item === 'string') {
//     item = false;
//   }
// }

/////ЗАМІНА ЕЛЕМЕНТА  В МАСИВІ ЧЕРЕЗ ЦИКЛ for (складні типи даних мутабельні, і їх можна змінювати навіть черз конст)//////////////////

// const array = [1, 'Hello', null, true, [1, 2, 3]];

// for (let i = 0; i < array.length; i++) {
//   if (typeof array[i] === 'string') {
//     // якщо елемент в масиві = стрінг тобто рядку (а це наше Хелоу) то в такому разі заміни його на інше значення(фолс)
//     array[i] = false;
//   }
// }
// console.log('for', array); //  [1, false, null, true, [1, 2, 3]];

//////////////////ЧЕРЕЗ while

// const array = [1, 'Hello', null, true, [1, 2, 3]];

// let i = 0; // перший блок ФОР // лічильник починається з нуля
// while (i < array.length) {
//   if (typeof array[i] === 'string') {
//     if (typeof array[i] === 'string') {
//       array[i] = false;
//     }
//   }
//   console.log(array[i]);
//   i++; // пост вираз
// }

/////////////////////////////////////// ПРИСВОЄННЯ ЗА ЗНАЧЕННЯМ І ЗА ПОСИЛАННЯМ

// складний тип даних - має одну комірку памяті
//примітивний тип даних має дві комірки памяті

///////////за значенням

// let value = 1; // примітивні типи даних
// let test = value; // це дві різні змінні
// value += 10;
// console.log('value', value); //11
// console.log('test', test); // 1

//////// за посиланням

// const array = [1, 2, 3, 4, 5];
// const copy = array; // сюди присвоюється посилання тобто масив [] і це вже буде одна змінна

// array.push(6, 7); // дадає елемент масиву
// copy.push(8, 9);
// console.log(array === copy); // true

// console.log(array); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(copy); //  [1, 2, 3, 4, 5, 6, 7, 8, 9]

///////////

// console.log(1 === 1); //true примітивні типи порівнюємо за значенням
// console.log('hello' === 'hello'); // true
// console.log([1, 2, 3] === [1, 2, 3]); // true складні типи порівнюємо за посиланням // створили два різних масиви

//////////////////////////ІМУТАБЕЛЬНІ ТА МУТАБЕЛЬНІ ТИПИ ДАНИХ/////////////////////

// всі примітивні типи даних -- НЕМУТАБЕЛЬНІ і мають присвоєння за значенням // є оператори присвоєння

// let number = 1;
// number += 5; //6
// console.log(number);

// складні типи даних (масив/об'єкт) -- МУТАБЕЛЬНІ і мають присвоєння за посиланням

// let array = [1, 2, 3];
// array = [1, 2, 3, 4]; // переприсвоїли значення
//array = 'string' // перевизначили масив на стрінг
// console.log(array[5]); // undefined --- бо не існує такого елемента  в масиві

// // array.push(4); // а тут мутували значення
// // array.pop(); // видаляє останній елемент масиву // а тут мутували значення
// // array.length = 0; // повністью очищує масив // а тут мутували значення
// console.log(array);

////////////////////////////МЕТОДИ МАСИВУ///////////////////////////////////////////

//  .split('')   --- перетворює з рядка в масив розбиваючи його роздільником
//  .join ('')  --- обєднує елементи масиву у рядок
// .revers() --- розвертає/повертає елементи / слова (те що було перше стане останнє і навпаки)

/////////////Задача 1 Поміняти слова місцями//////////////////
//спочатку ми слова розділюємо потім міняємо містами і потім назад поєднуємо

// const str = 'Hello world';
// const arr = str.split(' '); // 1. розділення посимвольно '' 2. розділеня по пробілу ' ' //() --сюди вказуємо як саме потрібно розділити
// const result = arr.reverse().join(' '); // з'єднуються елементи назад так само як і роз'єднувались
// console.log(result);

//////////////////скорочений варіант запису

// const str = 'Hello world I`m learning JS'; // деліметр - той символ чим розділяється рядок(тире, пробіл, посимвольно)

// const result = str.split(' ').reverse().join(' '); //роз'єднали - перевернули - з'єднали
// console.log(str);
// console.log(result);

//////////////РОЗВОРОТ ПО БУКВАМ/////////////////////////////

// const str = 'Hello'; // деліметр - той символ чим розділяється рядок(тире, пробіл, посимвольно) // якщо немає такого деліметра як ми вказали у спліт тоді весь рядок буде масивом
// const result = str.split('').reverse().join(''); //роз'єднали - перевернули - з'єднали
// console.log(str);
// console.log(result);

////////

// indexOf -- повертає індекс елемента починаючи з нуля, якщо не знайшов повертає - 1 --- перший неможливий індекс елемент в масиві
// includes -- перевіряє чи є даний елемент в масиві // true / false

// const arr = ['hello', 'world'];
// const idx = arr.indexOf('world'); // 1 // повертає індекс елемента hello - 0 world - 1, якщо не знайшов повертає -1 - перший неможливий індекс елемент в масиві
// ///перевірка чи є елемент в масиві////
// if (arr.indexOf('JS') === -1) {
//   console.log('NO');
// } else console.log('YES');
// console.log(idx);

////////////////////// ПЕРЕВІРКА ЧИ Є ЕЛЕМЕНТ В МАСИВІ//////////////////////

// const arr = ['hello', 'world'];

// if (arr.includes('JS')) {
//   console.log('YES');
// } else {
//   console.log('NO');
// }
// console.log(arr.includes('JS')); // false

////////////////////////МЕТОДИ ЯКІ МУТУЮТЬ МАСИВ//////////////////

// push -- додає в кінці елемент масиву
// pop -- видаляє останній елемент масиву
// shift -- видаляє елементи на початку масиву
// unsift -- додає елементи на початку масиву
// splice -- додає видаляє заміняє елемент масиву (універсальний)
// slice -- створює копію масиву (рідко викорис)
// concat -- поєднує декілька масивів в один

// const arr = ['hello', 'world'];
// arr.push(1, 45, 14);

// arr.pop(); // видалило 14 // скільки pop прописуємо скільки елементів і видаляє
// arr.pop(); //видалило 45
// // console.log(arr); // хелоу ворд 1

// arr.unshift(1, 'a');
// console.log(arr); // 1 а хелоу ворд 1

// // arr.shift(); //видаляє 1
// // arr.shift(); // видаляє а
// // console.log(arr); // хелоу ворд 1

// const result = arr.slice(1, 3); //створилась нова комірка памяті // (з якого, по який(не включно)) тобто (1,3) -- видалиться 1 і 2 // виводиться те що вирізали
// console.log(result);

// const arr = ['hello', 'world', 'js'];
// // arr.splice(1, 1, 'from'); //(який по індексу, скільки видалити) 'from' - заміна
// // console.log(arr); // тобто 1 елемент видалило і замінило на інший // hello from js

// arr.splice(1, 0, 'from', 'react', 'noda'); // якщо не потрібно видалити а просто додати, то він стане на той індекс що ми вказали йому
// console.log(arr); // hello from react noda world js

////дізнатися по індексу і замінити той елемент

// const arr = ['hello', 'world', 'js'];
// const idx = arr.includes('world'); //1
// const result = arr.splice(idx, 1, 'from'); // hello from js
// console.log(arr);
// console.log(result); //world  отримали те що вирізали

/////////////////////

// const arr = [1, 2, 3];
// const arr1 = [4, 5];
// const arr2 = [6, 7];
// const result = arr.concat(arr2, arr1); //підключаємо у будь якому порядку
// console.log(arr);
// console.log(result);

//////////////////////

// document.body.id = 1;
// console.log(typeof document.body.id); // typeof - string
// console.log(document.body.id === 1); //false

// input = 2;
// console.log(typeof input); // number
// console.log(input === 2); // true

//////////////////////////////////

// const array = ['Aple', 'mine', 'juice', 1, false];
// console.log(array.slice(0, 3)); //'Aple', 'mine', 'juice'//копіює масив

// const array = ['Aple', 'mine', 'juice', 1, false];
// console.log(array.indexOf('mine')); //1 // шукає індекс по назві

// const array = ['Aple', 'mine', 'juice', 1, false];
// console.log(array.splice(0, 0, 'my')); // [] -- дужки пусті бо нічого не видалило лише додали my
// console.log(array);

// const array3 = [0];
// const array = ['Aple', 'mine', 'juice', 1, false];
// const array2 = [8, 2, 'yellow'];
// const result = array.concat(array3, array2);
// console.log(result);

// .split('') --- перетворює з рядка в масив розбиваючи його роздільником
// .join ('') --- обєднує елементи масиву у рядок
// .revers() --- розвертає/повертає елементи / слова (те що було перше стане останнє і навпаки)

// const result = [1, 2, 3, 4, 5];
// const result = array.split(' ');
// console.log(array);

// let array = ['Hello', 'world'];
// array = array.join(' ');
// console.log(array);

//повертає декілька елементи з масива

// function getExtremeElements(array) {
//   if (array.length >= 2) {
//     return [array[0], array[array.length - 1]];
//   } else {
//     return array;
//   }
// }
// console.log(getExtremeElements([1, 2, 3, 4, 5])); //1, 5
//___________________________________________________________________________________________________________________________________________________________________________________________

///////////////////////////////////// функція - обгортка яка дозволяє робити якусь одну певну однотипну дію, змінюється лише вхідні параметри //////////////////////////////////////////

// Є два типа функцій: у declaration функцію можна викликати перед оголошенням у expression ні //  НАЗИВАЄТЬСЯ ТАКЕ - ХОСТІНГ - ЗДАТНІСТЬ ПІДНІМАТИСЯ (функція може підніматися)

////arguments -- вбудований псевдомасив або ітерабельний об'єктconst arr = [...arguments];

//1. function declaration --
//fnction name(){

//}

// //2. function expression (функція без назви) -- зберігається у певній зміні // можна до неї звернутися лише як оголосили і потім викликали

// const arr = [1, 2, 3, 4];
// const arr1 = [5, 6, 7, 8];
// const arr2 = [9, 10, 11, 12];

// const sum = function (input) {
//   for (let i = 0; i < input.length; i++) {
//     input[i] = input[i] * 2;
//   }
//   console.log(input);
// };
// sum(arr); // виклик функції
// sum(arr1);
// sum(arr2);

//1. Перебір масиву з використанням циклу

// const arr = [1, 2, 3, 4]; // премножити масив //  якщо один масив можемо використати цикл фор // а якщо декілька масивів то використовуємо уже функцію

// for (let i = 0; i < arr.length; i++) {
//   arr[i] = arr[i] * 2; // переоприділили значення // лічильник масиву і ми перемножаємо на 2//тобто кожне число масиву починаючи з першого числа(0 індекс) ми множимо на два
// }
// console.log(arr); //[2,4,6,8]

//2. Перебір масивів з використанням функції

// const arr = [1, 2, 3, 4];
// const arr1 = [5, 6, 7, 8];
// const arr2 = [9, 10, 11, 12];

// sum(arr); // виклик функції // у declaration функцію можна викликати перед оголошенням у expression ні //  НАЗИВАЄТЬСЯ ТАКЕ - ХОСТІНГ - ЗДАТНІСТЬ ПІДНІМАТИСЯ
// sum(arr1);
// sum(arr2);

// function sum(input) {
//   // () -- вказуємо що ми приймаємо // те що приходить у функцію // ні до чого не привязуємося
//   for (let i = 0; i < input.length; i++) {
//     input[i] = input[i] * 2;
//   }
//   console.log(input);
// }
// sum(arr); // виклик функції
// sum(arr1);
// sum(arr2);

////////////приклад функції якщо не знаємо скільки параметрів //ДОДАТИ ПАРАМЕТРИ МАСИВА

// function add(val, val1, val2, val3, val4, val5) {
//   console.log(val + val1 + val2 + val3 + val4 + val5); // у консоль виведеться три значення  add()
// }
// add(1, 2, 3, 4, 5, 6);
// add(1, 2, 3, 4); //NaN//як ми передали парметри так вони і прийдуть у функцію тобто val = 1 va1=2
// add(1, 2, 3, 4, 5); //NaN // бо не хватає параментрів у функції//ми не завжди знаємо скільки скільки їх буде в такому випадку існує параментр arguments

//////вірний приклад

// arguments -- вбудований псевдомасив або ітерабельний об'єкт// щоб перетоворити в масив   const arr = [...arguments]; /// якщо ми не знаємо скільки буде параметрів

// function add() {
//   let sum = 0; // оголошуємо зміну для виводу суми значень// по замовчуванню ставимо 0
//   console.log(arguments); // у консоль виведеться три значення  add()
//   for (let i = 0; i < arguments.length; i++) {
//     sum += arguments[i]; // sum = arguments[i] + sum;
//   }
//   console.log(sum);
// }
// add(1, 2, 3, 4, 5, 6);
// add(1, 2, 3, 4);
// add(1, 2, 3, 4, 5);

////ТОЙ САМИЙ ПРИКЛАД АЛЕ З ВИКОРИСТАННЯМ FOR OF + перетворюємо  arguments в масив

// function add() {
//   let sum = 0; // це зміна яка буде накопичувати в собі суму
//   //   const arr = Array.from(arguments); // не використовується
//   const arr = [...arguments];
//   console.log(arguments);
//   console.log(arr);

//   for (const result of arguments) {
//     sum += result;
//   }
//   console.log(sum);
// }

// add(1, 2, 3, 4, 5, 6);
// add(1, 2, 3, 4);
// add(1, 2, 3, 4, 5);

/////////////////////////////////////// ОПЕРАТОР RETURN ///////////////////////////////////////
//  return total // повертаємо те що опрацювуємо // без return буде undefined // return можна сказати перериває функцію //  змінна після рєтерн не читається, отже ретерн вказуємо в кінці функції // ретернів може бути безліч

// function add() {
//   let total = 0;
//   for (const value of arguments) {
//     total += value;
//   }

//   return total; // повертаємо те що опрацювуємо // без return буде undefined // return можна сказати перериває функцію
//   const value = 10; // змінна після рєтерн не читається
//   console.log(value);
// }

// const result = add(1, 2, 3, 4, 5, 6);
// console.log(result); // undefined // тому використовуємо return
// // add(1, 2, 3, 4);
// // add(1, 2, 3, 4, 5);
//////////////////////////////////////////////////////////////////////
// function largeNumber() {
//   let total = 0;
//   for (const value of arguments) {
//     total += value;
//     if (total > 10) {
//       return true;
//     }
//   }
//   return false;
// }

// const result = largeNumber(1, 2, 3); //6
// console.log(largeNumber(result));
// console.log(largeNumber(1, 2, 3, 4)); //10 але це не більше 10 тому false
// console.log(largeNumber(1, 2, 3, 4, 5)); //15 true

//////////////////як уникнути undefined//дефолтне значення//якщо не переданий один параметр////////////////////

// function add(value1, value2 = 0) {
//   return value1 + value2;
// }
// //value2=0 -- для того,що якщо переданий лише один параметр, то щоб не було undefined і не відбулося ніяких змін ставимо нуль по замувчуванню, розраховуємо на масив то ставимо value2=[], рядок - '', об'єкт - пустий об'єкт --- тобто розраховуємо на менше значення

// console.log(add(3, 4)); //7  по замовчуванню два значення приходить
// console.log(add(5)); // NaN бо лише один параметр // 5 + 0 = 5
// console.log(add(11)); //NaN //11 + 0 = 11

//////////////////////////////ОБЛАСТІ ВИДИМОСТІ ФУНКЦІЙ////////////////////////

//глобальна
//локальна

// let a = 10;
// function foo() {
//   a = 15;
// }
// console.log(a); // 10 ту що у функції не видно // щоб перевизначити функцію її необхідно  викликати

///////////та  сама функція

// let a = 10;
// function foo() {
//   a = 15;
// }
// foo(); //15 // виклик функції
// console.log(a); // вивід в консоль

/////інший приклад

// let a = 10;

// function foo() {
//   let a = 15;
// }
// foo(); // 10 // оскільки зміна 15 - оголошена локально
// console.log(a);

// //інший приклад

// let a = 10;

// function foo() {
//   let a = 15;
//   a = 45;
// }
// foo(); // 10 // не можемо потрапити в середину
// console.log(a);

////інший приклад

// let a = 10;

// function foo() {
//   a = 45;
//   let a = 15;
// }
// foo(); // eror // область видимості в пріорітеті, тому виводить перша помилка
// console.log(a);

/////інший приклад

// let a = 10;

// function foo(a) {
//   a = 45;
// }
// foo(); // 10
// console.log(a);

// /////інший приклад

// let a = 10;

// function foo(a) {
//   a = 45;
// }
// foo(a); // 10 -- змінна тут лише одна 10
// console.log(a);

/////інший приклад

// const test = [1, 2, 3];

// function foo(arr) {
//   let arr = test; // тобто арр став = тест - одна комірка памяті
//   arr.splice(0, 1); // вирізали перший елемент (індекс 0) скільки(1)
// }
// foo(test);
// console.log(test); // 2,3

/////////////////////////////СТЕК ВИКЛИКІВ ФУНКЦІЙ ///CALL STACK// використання 2 функцій для обрахунку віку і показу на екран

// function createString(name, year) {
//   const result = add(year); // у змінну присвоюється результат виконання другої функції
//   return `${name} years ${result}`;
// }
// console.log(createString('Mango', [1, 2, 3]));

// function add(arr) {
//   let sum = 0;
//   for (const num of arr) {
//     sum += num;
//   }
//   return sum;
// }
// функціїї викликаються по черзі// коли опрацювується
//  функція перша чекає коли опрацювалася друга то опрацювується перша і завернується виконання

///////////////////////////////// переповнення CALL STECK функцій

// function foo() {
//   boo();
// }
// foo();
// function boo() {
//   foo(); // Uncaught RangeError: Maximum call stack size exceeded // ПЕРЕПОВНЕНИЙ CALL STECK // одна функція накладається на іншу і ходимо по колу
// }

//////// у вайл може бути переповнення а у функції ні, лише спрацювує помилка

// while (true) {
//   console.log(true);
// }

////////////////////////////////////////////////////////////////////

// const array = ['red', 'blue', 'boom', 'doll'];
// console.log(Array.isArray(array)); // true

// const first = array[0];
// console.log(first);

//останній елемент 1 приклад

// const last = array.length - 1;
// const lastElement = array[last];
// console.log(lastElement); // doll

//останній елемент 2 приклад

// console.log(array[array.length - 1]); // doll

////ПЕРЕБІР МАСИВУ

//Цикл for

// for (let i = 0; i < array.length; i++) {
//   console.log(i); // вивели що під яким елементом знаходиться
//   let element = array[i];
//   console.log(element);
// }

//Цикл for of -- якщо не потрібно знати індекс елемента то можна використати фор оф// і якщо не потрібно щось додавати чи видаляти з масиву

// for (const item of array) {
//   // на кожній ітерації ця константа (item) буде чомусь =
//   console.log(item);
// }

//////////////ТИПИ ДАНИХ

// за посиланням (одна комірка)

// const numbers = [1, 2, 3, 4, 5];
// const item = numbers; // це один масив( складний тип даних)
// console.log(numbers); // 1, 2, 3, 4, 5
// console.log(item); // 1, 2, 3, 4, 5

// numbers[0] = 10; //

// console.log(numbers); // 10, 1, 2, 3, 4, 5
// console.log(item); // 10, 1, 2, 3, 4, 5

// console.log(item === numbers); // true

//за значенняm (дві окремі комірки)

// let a = 10;
// let b = a;
// console.log(a); //10
// console.log(b); //10

// a = 15;

// console.log(a); //15
// console.log(b); // 10

//////////////////////////////

// includes

// const array = [[1], [2], [3]];
// console.log(array.includes([1])); // false // оскільки це два різних масива вони зрівнюються саме по місці у памяті

//////інший приклад

// const arr1 = [1];
// const array = [arr1, [2], [3]];
// console.log(array.includes(arr1)); // true // оскільки це два різних масива вони зрівнюються саме по місці у памяті

///////concat

// const str = [1, 2, 3, 4, 5];
// const numbers = [6, 7, 8, 9];
// console.log(str.concat(numbers, ['hello'])); // можна додавати не лише масиви
